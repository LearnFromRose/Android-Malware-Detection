"""

将Android.jar包反编译成java代码, 提取其中的标准API函数

"""


import os
import sys
import re


def get_file_list(dir_path: str) -> list:
    """
    传入根目录，遍历出所有的文件路径
    :param dir_path: 根目录
    :return: 文件路径列表
    """
    fs = []
    for root, dirs, files in os.walk(dir_path):
        for f in files:
            if f.endswith('.java'):
                fs.append(root + '/' + f)
    return fs


def parse_java_file(file_path: str, root_path: str):
    """
    传入java源文件路径，解析其中的函数
    :param root_path: 根目录
    :param file_path: 要解析的文件
    :return:
    """
    f = open(file_path, encoding='utf-8')
    context = f.read()
    f.close()
    pattern_method = re.compile(
        r'^[\s]*'
        r'(public|protected|private)[\s]*'
        r'(static)*[\s]*'
        r'(final|abstract)*[\s]*'
        r'([\w]*)[\s]*'
        r'([\w]*)'
        r'\((.*)\)'
        r'$',
        re.M)
    pattern_import = re.compile(
        r'^(import)[ \t]*([\w\.\$]*)(;)$',
        re.M)
    methods = re.findall(pattern_method, context)
    classes = re.findall(pattern_import, context)
    class_package_map = get_class_package_map(classes, file_path, root_path)
    ms = []
    for i in methods:
        # print(i)
        if Method(i, class_package_map, file_path[len(root_path):]).get_method_info()!='':
            ms.append(Method(i, class_package_map, file_path[len(root_path):]).get_method_info())
            print(Method(i, class_package_map, file_path[len(root_path):]).get_method_info())
    return ms


def get_class_package_map(classes: list, file_path: str, root_path: str) -> dict:
    """
    利用引入的包文件，构造 类与其所属包 的对应字典
    :param root_path:
    :param file_path:
    :param classes:
    :return:
    """
    m = {}
    # 第一部分：当前文件引入的包
    for c in classes:
        name = c[1].split('.')[-1]
        m[name] = c[1]

    # 第二部分：当前java文件同一个包的其他类
    dir = ''  # 获取当前文件所在文件夹路径
    for i in re.split(r'[/\\]', file_path)[:-1]:
        dir += i + '/'
    fs = get_file_list(dir)  # 获取所在文件夹所有文件
    for f in fs:
        name, pack = path_format(f[len(root_path):])
        m[name] = pack

    # 第三部分：当前文件的内部类和接口
    pattern_inner_lass_interface = re.compile(
        r'^[\s]*(public|private|protected)[\s]*'
        r'(static|final|abstract)*[\s]*'
        r'(class|interface)[\s]*'
        r'([\w|\$|\.|_|\<|\>]*)[\s]*'
        r'[\w|_|\$| |,|\s|\.|\[|\]|\<|\>|\:|\?|@]*\{',
        re.M)
    f = open(file_path, 'r', encoding='utf-8')  # gbk 格式的文件,以 utf-8 格式打开就行
    context = f.read()
    f.close()
    cs = re.findall(pattern_inner_lass_interface, context)
    this_class_name, this_class_path = path_format(file_path[len(root_path):])
    for t in cs:
        if t[3] != this_class_name:
            # 去掉内部类（接口）名称中的<>其中的内容<>之中往往是<T>等泛型，在内部类包引用中没有用处，直接去掉也方便后面map的构造
            flag = 0
            tmp = ''
            i = 0
            while i < len(t[3]):
                if t[3][i] == '<':
                    flag = 1
                if flag == 0:
                    tmp += t[3][i]
                if t[3][i] == '>':
                    flag = 0
                i += 1
            m[tmp] = this_class_path + '.' + tmp
    return m


def path_format(path: str) -> tuple:
    """
        Android 系统 API 的相对路径格式化：
            android-23\android\accessibilityservice\AccessibilityService.java
       格式化为：
           android.accessibilityservice.AccessibilityService
    :param path:
    :return:
    """
    t = re.split(r'[/\\]', path)
    name = t[-1].split('.')[0]
    pack = ''
    for i in t[:-1]:
        if i != '':
            pack += i + '.'
    pack += name
    return name, pack


class Method:
    def __init__(self, tup: tuple, class_package_map: dict, relative_file_path: str):
        self.src = ''
        self.__parse(tup, class_package_map, relative_file_path)

    def __parse(self, tup: tuple, class_package_map: dict, relative_file_path: str):
        self.accessControlType = tup[0]
        self.isStatic = True if 'static' in tup[1] else False
        self.isFinal = True if 'final' in tup[2] else False
        self.isAbstract = True if 'abstract' in tup[2] else False
        self.returnType = class_package_map[tup[3]] if tup[3] in class_package_map else tup[3]
        self.name = tup[4]
        _, path = path_format(relative_file_path)
        self.name = path + '.' + self.name

        if self.name == '':  # 构造函数情况，无返回类型，函数名被匹配到了返回类型上
            self.name = self.returnType + '.' + tup[3]
            self.returnType = ''
        self.args = []
        args = tup[5].split(',')
        for a in args:
            for i in a.split(' '):
                if i != '':
                    self.args.append(class_package_map[i] if i in class_package_map else i)
                    break
        # self.src += self.accessControlType + ' '
        # self.src += 'static ' if self.isStatic else ''
        # self.src += 'final ' if self.isFinal else ''
        # self.src += 'abstract ' if self.isAbstract else ''
        self.src += self.name
        self.src += '('
        for a in self.args:
            self.src += a + ','
        self.src = self.src[:-1]
        self.src += ')'
        self.src += self.returnType

    def get_method_info(self):
        if self.name[-1] == '.':
            return ''
        return self.src


if __name__ == '__main__':
    fileDir = '.\\src'
    fileList = get_file_list(fileDir)
    # parse_java_file(".\\src\\org\\w3c\\dom\\Node.java", fileDir)
    output = sys.stdout
    outputfile = open('api.txt', 'w')
    sys.stdout = outputfile
    count = 0
    for f in fileList:
        count += len(parse_java_file(f, fileDir))
    # 关闭输出重定向
    outputfile.close()
    sys.stdout = output
    print(count)
