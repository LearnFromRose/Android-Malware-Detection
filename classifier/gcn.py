import tensorflow as tf
import scipy.io as io
import numpy as np
import scipy.sparse as sp

x = tf.placeholder(tf.float32, shape=(1061, 1061))
y = tf.placeholder(tf.int32, shape=(None, 1))
index = tf.placeholder(tf.int32, shape=(None,))
m = tf.placeholder(tf.float32, shape=(1061, 1061))
y_hot = tf.one_hot(y, 2)
h1 = tf.keras.layers.Dense(1061, tf.nn.relu)(tf.multiply(m, x))
h2 = tf.keras.layers.Dense(1061)(tf.multiply(m, h1))
dropout = tf.layers.dropout(
    inputs=h2,
    rate=0.5
)
h3 = tf.keras.layers.Dense(128)(dropout)
h4 = tf.keras.layers.Dense(2)(h3)

logits = tf.nn.embedding_lookup(h4, index)
loss1 = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(labels=y_hot, logits=logits))
train_op = tf.train.AdamOptimizer(0.001).minimize(loss1)


def compute_acc(logits, labels):
    pre = np.argmax(logits, 1).astype(np.int32).reshape((-1, 1))
    labels = labels.astype(np.int32)
    acc = np.mean(np.equal(pre, labels).astype(np.float32))
    return acc


def normalize_adj(adj):
    """Symmetrically normalize adjacency matrix."""
    adj = sp.coo_matrix(adj)
    rowsum = np.array(adj.sum(1))
    d_inv_sqrt = np.power(rowsum, -0.5).flatten()
    d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0.
    d_mat_inv_sqrt = sp.diags(d_inv_sqrt)
    return adj.dot(d_mat_inv_sqrt).transpose().dot(d_mat_inv_sqrt.toarray())


def preprocess_adj(adj):
    """Preprocessing of adjacency matrix for simple GCN model and conversion to tuple representation."""
    adj_normalized = normalize_adj(adj + sp.eye(adj.shape[0]))
    return adj_normalized


with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    d = io.loadmat("..\\dataset\\benignAndStormDroid\\A.mat")
    A = d["X"].astype(int)
    Y = d["Y"].astype(int).ravel()
    A = sp.coo_matrix(A)
    # # print(A.data.shape)
    # print(A.shape)
    # adj = A
    adj = A.dot(A.T)
    adj = normalize_adj(adj)
    # adj[np.where(adj<=1)] = 0
    index1 = list(range(1061))
    np.random.shuffle(index1)
    train_label = Y[index1[:700]].reshape(-1, 1)
    test_label = Y[index1[700:]].reshape(-1, 1)
    index_tr = np.array(index1[:700]).reshape(-1, )
    index_te = np.array(index1[700:]).reshape(-1, )
    adjmatix = np.eye(1061)
    for i in range(1000):
        _, loss_tr, l_tr = sess.run([train_op, loss1, logits],
                                    feed_dict={x: adjmatix, y: train_label, index: index_tr, m: adj})
        loss_te, l_te = sess.run([loss1, logits], feed_dict={x: adjmatix, y: test_label, index: index_te, m: adj})
        acc_1 = compute_acc(l_tr, train_label)
        acc_2 = compute_acc(l_te, test_label)
        print("Epoch:", '%04d' % (i), "train_loss=", "{:.5f}".format(loss_tr),
              "train_acc=", "{:.5f}".format(acc_1), "val_loss=", "{:.5f}".format(loss_te),
              "val_acc=", "{:.5f}".format(acc_2))
